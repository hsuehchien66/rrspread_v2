#' Plot Gubbin Tree
#'
#' This function generates Gubbins Tree plot.
#'
#' @param gubbin_tree tree file generated by Gubbins
#' @return plot of Gubbins tree
#' @export
plt_gubbin_tree = function(gubbin_tree){
  plt_tree = plot(gubbin_tree, "c",FALSE, cex=0.6, no.margin = TRUE)
  return(plt_tree)
}

#' Match Tree Label to Metadata Label
#'
#' This function generates pairwise matrices from metadata file.
#'
#' @param Metadata metadata file
#' @param Tree tree file generated from Gubbins
#' @param drop_tip_name the name of the tip to be dropped, usually the reference name
#' @param drop_tip TRUE to drop the tip of drop_tip_name
#' @return a list with (1) a tree after dropping tip, and (2) a dataframe with matched tree and metadata label
#' @export
match_tree_meta = function(Metadata, Tree, drop_tip_name, drop_tip = TRUE){
  if (drop_tip){
    ## drop reference tip from Gubbin tree
    tree_dropRef = drop.tip(Tree,drop_tip_name)
    ## create vector of tip labels
    id_order = tree_dropRef$tip.label
  } else{
    tree_dropRef = Tree
    id_order = Tree$tip.label
  }
  ## reorder tree based on order of tip labels (the order of the tip label should be the same in the lane_id)
  match_order = Metadata %>%
    dplyr::slice(match(id_order,lane_id))

  res_list = list("tree" = tree_dropRef, "match_tree_meta" = match_order)
  return(res_list)
}

#' Divergence time estimated by Bactdating
#'
#' This function generates estimated divergence time between isolates
#'
#' @param match_tree_meta metadata file of combining tree file and metafile
#' @param dropRef_tree tree file generated from match_tree_meta
#' @param save_bd_path path to save bactdating results
#' @param time use "Year_collection" by default
#' @return (1) roottotip and (2) bactdating results
#' @export
time_resolved = function(match_tree_meta, dropRef_tree, save_bd_path, time="Year_collection", n_it=50000, branch_model="arc"){
  collectionTime = as.numeric(match_tree_meta[, time])
  rtd = roottotip(dropRef_tree, collectionTime)
  bd = bactdate(unroot(dropRef_tree), collectionTime, showProgress = T, nbIts = n_it, model=branch_model) ## MCMC process
  saveRDS(bd, save_bd_path)

  res_list = list("Root2Tip" = rtd, "BactDating" = bd)
  return(res_list)
}

#' Binding multiple trees
#'
#' This function binds multiple trees
#'
#' @param ... tree files
#' @return a tree with multiple trees
#' @export
bind_multitree = function(...){
  tree_list = list(...)
  initial_tree = bind.tree(tree_list[[1]], tree_list[[2]])
  for (i in 3:length(tree_list)){
    tmp_tree = bind.tree(initial_tree,tree_list[[i]])
    initial_tree = tmp_tree
  }
  return(initial_tree)
}

#' Generate distance matrix
#'
#' This function generates pairwise numeric distance matrix and binary distance matrix based on the given thresholds
#'
#' @param metadata metadata file with longitude and latitude information
#' @param min_dist minimum distance threshold
#' @param max_dist maximum distance threshold
#' @return (1) a pairwise numeric distance matrix, and (2) a pairwise binary distance matrix
#' @export
gen_dist_mat <- function(metadata, min_dist, max_dist){
  lane.names <- metadata$lane_id
  vector_longitude <- metadata$Longitude
  vector_latitude <- metadata$Latitude

  lonlat_list1 = data.frame(longitude = vector_longitude,
                            latitude = vector_latitude)
  lonlat_list2 = data.frame(longitude = vector_longitude,
                            latitude = vector_latitude)

  distance_mat = distm(lonlat_list1[,c("longitude","latitude")], lonlat_list2[,c("longitude","latitude")], fun = distHaversine)
  distance_mat = distance_mat / 1000 ## change to km
  distance_num_mat = distance_mat
  distance_mat[distance_mat==0] <- min(distance_mat[distance_mat!=0]) ## set minimal distance
  diag(distance_mat) = NA
  colnames(distance_mat) = lane.names
  rownames(distance_mat) = lane.names

  distance_mat = (distance_mat > min_dist)*(distance_mat <= max_dist) ## within designated distance

  res_list = list("pairwise_distance_matrix" = distance_num_mat,
                  "distance_RRmatrix" = distance_mat)

  return(res_list)
}

#' Generate divergence time matrix
#'
#' This function generates pairwise numeric divergence time matrix and binary divergence time matrix based on the given thresholds
#'
#' @param metadata metadata file with collection time information
#' @param bactdate_tree tree output generated by bactdacting
#' @param min_time minimum divergence time threshold
#' @param max_time maximum divergence time threshold
#' @param coltime_range
#' @return (1) a pairwise numeric divergence time matrix, and (2) a pairwise binary divergence time matrix
#' @export
gen_divtime_mat <- function(metadata, bactdate_tree, min_time, max_time){
  matched_tree_meta_table = match_tree_meta(Metadata = metadata, Tree = bactdate_tree,
                                            drop_tip_name = "", drop_tip = FALSE)
  matched_table = matched_tree_meta_table$match_tree_meta
  lane.names <- matched_table$lane_id
  vector_coltime = matched_table$Year_collection
  vector_coltime = vector_coltime + runif(length(vector_coltime), min = -0.01, max = 0.01)

  coltime_mat = abs(outer(vector_coltime, vector_coltime, "-"))
  diag(coltime_mat) <- NA
  coltime_num_mat = coltime_mat

  dtime.mat <- cophenetic.phylo(bactdate_tree) ## cophenetic.phylo: compute the pairwise distance between the pairs of tips from a phlyogenetic tree
  diag(dtime.mat) <- NA
  divtime_mat <- (dtime.mat-coltime_num_mat)/2
  divtime_num_mat = divtime_mat
  divtime_mat = (divtime_mat > min_time)*(divtime_mat <= max_time) ## diverge within 50 years

  res_list = list("pairwise_divtime_matrix" = divtime_num_mat,
                  "divtime_RRmatrix" = divtime_mat)

  return(res_list)
}


#' Generate Pairwise Matrix for Relative Risk Calculation
#'
#' This function generates pairwise matrices from metadata file and bactdating tree
#'
#' @param meta_table metadata, should include GPSC, region, longitude, latitude, collection year
#' @param bactdate_tree tree file generated from bactdating
#' @param coltime_range given range of collection time
#' @param des_divtime_min given minimum designated divergence time
#' @param des_divtime_max given maximum designated divergence time
#' @param ref_divtime_min reference minimum divergence time
#' @param ref_divtime_max reference maximum divergence time
#' @param des_distance_min given minimum designated distance
#' @param des_distance_max given maximum designated distance
#' @param ref_distance_min reference minimum distance
#' @param ref_distance_max reference maximum distance
#' @return pairwise matrices, including (1) pairwise designated lineage matrix, (2) pairwise reference lineage matrix, (3) pairwise designated location matrix, (4) pairwise reference location matrix, (5) pairwise designated binary distance matrix, (6) pairwise reference binary distance matrix, (7) pairwise designated binary divergence time matrix, (8) pairwise reference binary divergence time matrix, (9) pairwise numeric distance matrix, (10) pairwise divergence time matrix, (11) pairwise collection time matrix
#' @export
RR_matrix = function(meta_table, bactdate_tree, coltime_range = 1,
                     des_divtime_min = 0, des_divtime_max = 50, ref_divtime_min = 70, ref_divtime_max = 150,
                     des_distance_min = 0, des_distance_max = 50, ref_distance_min = 200, ref_distance_max = 300){
  lane.names <- meta_table$lane_id

  vector_lineage = meta_table$GPSC_PoPUNK2
  vector_location = meta_table$REGION
  vector_longitude <- meta_table$Longitude
  vector_latitude <- meta_table$Latitude
  vector_coltime = meta_table$Year_collection
  vector_coltime = vector_coltime + runif(length(vector_coltime), min = -0.01, max = 0.01)

  des_lineage_mat = abs(outer(vector_lineage, vector_lineage, "=="))
  diag(des_lineage_mat) <- NA
  colnames(des_lineage_mat) = lane.names
  rownames(des_lineage_mat) = lane.names
  ref_lineage_mat = 1- des_lineage_mat

  des_location_mat = abs(outer(vector_location, vector_location, "=="))
  diag(des_location_mat) <- NA
  colnames(des_location_mat) = lane.names
  rownames(des_location_mat) = lane.names
  ref_location_mat = 1 - des_location_mat

  coltime_mat = abs(outer(vector_coltime, vector_coltime, "-"))
  diag(coltime_mat) <- NA
  colnames(coltime_mat) = lane.names
  rownames(coltime_mat) = lane.names
  coltime_mat = (coltime_mat > 0)*(coltime_mat <= coltime_range) ## within a year

  des_distance_mat = gen_dist_mat(metadata = meta_table, min_dist = des_distance_min, max_dist = des_distance_max)
  ref_distance_mat = gen_dist_mat(metadata = meta_table, min_dist = ref_distance_min, max_dist = ref_distance_max)

  des_divtime_mat = gen_divtime_mat(metadata = meta_table, bactdate_tree = bactdate_tree, min_time = des_divtime_min, max_time = des_divtime_max)
  ref_divtime_mat = gen_divtime_mat(metadata = meta_table, bactdate_tree = bactdate_tree, min_time = ref_divtime_min, max_time = ref_divtime_max)

  res_list = list("des_lineage_mat" = des_lineage_mat,
                  "ref_lineage_mat" = ref_lineage_mat,
                  "des_location_mat" = des_location_mat,
                  "ref_location_mat" = ref_location_mat,
                  "des_distance_mat" = des_distance_mat$distance_RRmatrix,
                  "ref_distance_mat" = ref_distance_mat$distance_RRmatrix,
                  "des_divtime_mat" = des_divtime_mat$divtime_RRmatrix,
                  "ref_divtime_mat" = ref_divtime_mat$divtime_RRmatrix,
                  "distance_num_mat" = ref_distance_mat$pairwise_distance_matrix,
                  "divtime_num_mat" = ref_divtime_mat$pairwise_divtime_matrix,
                  "coltime_mat" = coltime_mat)
  return(res_list)
}


#' Calculate relative risk ratio
#'
#' This function calculates relative risk ratio with the input matrices generated by RR_matrix
#'
#' @param x subsampled isolates
#' @param des_geo_matrix designated geo_matrix generated by RR_matrix: des_location_mat or des_distance_mat
#' @param ref_geo_matrix reference geo_matrix generated by RR_matrix: ref_location_mat or ref_distance_mat
#' @param des_strain_matrix designated strain_mat generated by RR_matrix: des_lineage_mat or des_divtime_mat
#' @param ref_strain_matrix reference strain_mat generated by RR_matrix: ref_lineage_mat or ref_divtime_mat
#' @param colyear_matrix collection time matrix generated by RR_matrix: coltime_mat
#' @return rr, relative risk ratio
#' @export
Geo_Strain_Calc_RR <- function(x, des_geo_matrix, ref_geo_matrix, des_strain_matrix, ref_strain_matrix, colyear_matrix){
  des_geo_mat.tmp = des_geo_matrix[x,x]       #pairwise geolocation matrix, subsetting by subsampling
  ref_geo_mat.tmp = ref_geo_matrix[x,x]
  time_mat.tmp = colyear_matrix[x,x]  #pairwise collection year matrix
  strain_mat.tmp = des_strain_matrix[x,x] #pairwise lineage matrix
  tmp = des_geo_mat.tmp * time_mat.tmp    #dot product
  tmp[which(tmp==0)] = NA

  tmp2 = ref_geo_mat.tmp * time_mat.tmp
  tmp2[which(tmp2 == 0)] = NA

  a = sum(tmp*strain_mat.tmp, na.rm = T)    #counts of all the isolates in same location, same lineage, same collection year
  b = sum(tmp, na.rm = T)                   #counts of all the isolates in same location and same collection year
  c = sum(tmp2*strain_mat.tmp, na.rm = T)   #counts of all the isolates in different locations, same lineage, same collection year
  d = sum(tmp2, na.rm = T)                  #counts of all the isolates in different locations and same collection time
  rr = (a/b)/(c/d)
  if (max(rr, na.rm = T) > 1E10){
    rr = ((a+1)/(b+1))/((c+1)/(d+1))
  }
  if (is.na(rr) == T | rr[1]==0){
    rr = ((a+1)/b)/(c/d)
  }
  return(rr)
}


#' Calculate confidence interval of relative risk ratio
#'
#' This function calculates confidence interval of relative risk ratio by bootstrapping
#'
#' @param metadataset metadata, should include GPSC, region, longitude, latitude, collection year
#' @param des_geo_matrix designated geo_matrix generated by RR_matrix: des_location_mat or des_distance_mat
#' @param ref_geo_matrix reference geo_matrix generated by RR_matrix: ref_location_mat or ref_distance_mat
#' @param des_strain_matrix designated strain_mat generated by RR_matrix: des_lineage_mat or des_divtime_mat
#' @param ref_strain_matrix reference strain_mat generated by RR_matrix: ref_lineage_mat or ref_divtime_mat
#' @param colyear_matrix collection time matrix generated by RR_matrix: coltime_mat
#' @param nboot number of bootstrapping
#' @param subsample_min number of subsample
#' @return relative risk with confidence interval
#' @export
RR_bootstrap = function(metadataset,
                        des_geo_matrix, ref_geo_matrix,
                        des_strain_matrix, ref_strain_matrix,
                        colyear_matrix,
                        nboot = 20, subsample_min = 70){
  nseq = nrow(metadataset)
  #nboot = 20
  boot.out = matrix(NA, 1, nboot+1) # create output matrix 1x(nboot+1), check if not +1

  for (j in 1:nboot){
    ## subsample each region ##
    selectedSeqs = NULL
    uni_region_vec = unique(metadataset$REGION)
    region_vec = metadataset$REGION

    for (i in 1:length(uni_region_vec)){
      a = which(region_vec==uni_region_vec[i])        #select a certain region (index)
      b = sample(a, min(subsample_min, length(a)), replace = F)  #subsample without replacement (index)
      selectedSeqs = c(selectedSeqs, b)               #collect selected samples in a certain region (index)
                                                      ## not overrepresenting samples from one place (sampling problem)
    }
    tmp = sample(selectedSeqs, replace = T)           #tmp is a set of selected sample from a certain region
    ## end subsampling
    rr = Geo_Strain_Calc_RR(x=tmp,
                            des_geo_matrix = des_geo_matrix,
                            ref_geo_matrix = ref_geo_matrix,
                            des_strain_matrix = des_strain_matrix,
                            ref_strain_matrix = ref_strain_matrix,
                            colyear_matrix = colyear_matrix)
    boot.out[,j] = rr                                 #write the rr in the bootstrap matrix
    print(j) #print which bootstrap you are on
  }

  boot.ci = quantile(boot.out, probs = c(0.025, 0.975), na.rm=T) #calculate confidence interval
  boot.med = quantile(boot.out, probs = c(0.5), na.rm=T) #calculate the median

  mat = matrix(nrow=1, ncol=3)
  mat[1,1] = boot.med
  mat[1,2] = boot.ci[1]
  mat[1,3] = boot.ci[2]
  mat = as.data.table(mat)

  colnames(mat) = c("RR_mean", "RR_lower_ci", "RR_upper_ci")
  mat$RR_mean = as.numeric(mat$RR_mean)
  mat$RR_lower_ci = as.numeric(mat$RR_lower_ci)
  mat$RR_upper_ci = as.numeric(mat$RR_upper_ci)

  return(mat)

  p = ggplot(data=mat, aes(x=1, y=RR_mean)) +
    geom_boxplot(width = 0.01)
    geom_errorbar(aes(ymin = RR_lower_ci))
}


#' Generate relative risk ratio plot
#'
#' This function plot relative risk ratio
#'
#' @param rrData relative risk generated by RelativeRisk()
#' @param RRplotTitle name of the plot
#' @param x_title name of the x axis
#' @return relative risk plot
#' @export
PltRR = function(rrData, RRplotTitle, x_title){
  p <- ggplot(rrData, aes(x=1, y=RR_mean))+
    geom_pointrange( aes(ymin = RR_lower_ci, ymax = RR_upper_ci), alpha=0.9) +
    geom_hline(yintercept=1, linetype="dashed", color = "red") + ##dashed line at 1
    scale_y_log10()+
    ylab("Risk Ratio")+
    xlab(x_title)+
    #ggtitle(RRplotTitle)+
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          panel.background = element_blank(), axis.line = element_line(colour = "black"),
          axis.text.x=element_blank(),axis.ticks.x=element_blank())

  return(p)
}



#' Generate relative risk ratio plot with rolling distance
#'
#' This function plot relative risk ratio with rolling distance
#'
#' @param rrData relative risk generated by RelativeRisk()
#' @param RRplotTitle name of the plot
#' @param xname name of the x label
#' @return relative risk plot with rolling distance
#' @export
PltRR_rolling = function(rrData,RRplotTitle, xname){
  p <- ggplot()+
    geom_pointrange(data=rrData, mapping=aes(x=xname, y=RR_mean, ymin = RR_lower_ci, ymax = RR_upper_ci), alpha=0.9) +
    geom_hline(yintercept=1, linetype="dashed", color = "red") + ##dashed line at 1
    scale_y_log10()+
    ylab("Risk Ratio")+
    xlab("Distance window (km)")+
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          panel.background = element_blank(), axis.line = element_line(colour = "black"))

  return(p)
}

#' Generate relative risk ratio plot with rolling divergence time
#'
#' This function plot relative risk ratio with rolling divergence time
#'
#' @param rrData relative risk generated by RelativeRisk()
#' @param RRplotTitle name of the plot
#' @return relative risk plot with rolling distance
#' @export
PltRR_rolling_divtime = function(rrData,RRplotTitle){
  p <- ggplot()+
    geom_pointrange(data=rrData, mapping=aes(x=as.factor(divtime_mid), y=RR_mean, ymin = RR_lower_ci, ymax = RR_upper_ci), alpha=0.9) +
    geom_hline(yintercept=1, linetype="dashed", color = "red") + ##dashed line at 1
    #scale_y_log10(limits = c(0.1,5e1))+
    ylab("Risk Ratio")+
    xlab("Divergence Time (years)")+
    theme(panel.grid.major = element_blank(), panel.grid.minor = element_blank(),
          panel.background = element_blank(), axis.line = element_line(colour = "black"))

  return(p)
}

#' Extract upper diagnal matrix
#'
#' This function extracts upper diagnal matrix
#'
#' @param X input matrix
#' @return upper diagnal matrix
#' @export
to.upper <- function(X){
  a = t(X)[lower.tri(X, diag = FALSE)]
  return(a)
}

#' Generate Pairwise Matrix for Relative Risk Calculation without tree
#'
#' This function generates pairwise matrices from metadata file and bactdating tree
#'
#' @param meta_table metadata, should include GPSC, region, longitude, latitude, collection year
#' @param coltime_range given range of collection time
#' @param des_distance_min given minimum designated distance
#' @param des_distance_max given maximum designated distance
#' @param ref_distance_min reference minimum distance
#' @param ref_distance_max reference maximum distance
#' @return pairwise matrices, including (1) pairwise designated lineage matrix, (2) pairwise reference lineage matrix, (3) pairwise designated location matrix, (4) pairwise reference location matrix, (5) pairwise designated binary distance matrix, (6) pairwise reference binary distance matrix, (7) pairwise numeric distance matrix, (8) pairwise divergence time matrix, (9) pairwise collection time matrix
#' @export
RR_matrix_notree = function(meta_table, coltime_range = 1,
                     des_distance_min = 0, des_distance_max = 50, ref_distance_min = 200, ref_distance_max = 300){
  lane.names <- meta_table$lane_id

  vector_lineage = meta_table$GPSC_PoPUNK2
  vector_location = meta_table$REGION
  vector_longitude <- meta_table$Longitude
  vector_latitude <- meta_table$Latitude
  vector_coltime = meta_table$Year_collection
  vector_coltime = vector_coltime + runif(length(vector_coltime), min = -0.01, max = 0.01)

  des_lineage_mat = abs(outer(vector_lineage, vector_lineage, "=="))
  diag(des_lineage_mat) <- NA
  colnames(des_lineage_mat) = lane.names
  rownames(des_lineage_mat) = lane.names
  ref_lineage_mat = 1- des_lineage_mat

  des_location_mat = abs(outer(vector_location, vector_location, "=="))
  diag(des_location_mat) <- NA
  colnames(des_location_mat) = lane.names
  rownames(des_location_mat) = lane.names
  ref_location_mat = 1 - des_location_mat

  coltime_mat = abs(outer(vector_coltime, vector_coltime, "-"))
  diag(coltime_mat) <- NA
  colnames(coltime_mat) = lane.names
  rownames(coltime_mat) = lane.names
  coltime_mat = (coltime_mat > 0)*(coltime_mat <= coltime_range) ## within a year

  des_distance_mat = gen_dist_mat(metadata = meta_table, min_dist = des_distance_min, max_dist = des_distance_max)
  ref_distance_mat = gen_dist_mat(metadata = meta_table, min_dist = ref_distance_min, max_dist = ref_distance_max)

  res_list = list("des_lineage_mat" = des_lineage_mat,
                  "ref_lineage_mat" = ref_lineage_mat,
                  "des_location_mat" = des_location_mat,
                  "ref_location_mat" = ref_location_mat,
                  "des_distance_mat" = des_distance_mat$distance_RRmatrix,
                  "ref_distance_mat" = ref_distance_mat$distance_RRmatrix,
                  "distance_num_mat" = ref_distance_mat$pairwise_distance_matrix,
                  "coltime_mat" = coltime_mat)
  return(res_list)
}
